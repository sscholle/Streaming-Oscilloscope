var express = require('express');
var app = express();
var router = express.Router();
var http = require('http').Server(app);
var port = process.env.PORT || 8000;

app.get('/', function(req, res){
  res.sendFile(__dirname + '/src/frontend/index.html');
});

app.use('/static', express.static(__dirname+'/src/frontend/public'));

http.listen(port, function(){
  console.log('listening on *:' + port);
});


// TODO: Try using WebRTC which will hopefully manage the traffic better


const SOCKET_PORT = 8080;

var bytesWritten = 0;
var readableStream = require('./src/backend/dummy-streamer'); // use a dummy streamer for testing
var ws = require("nodejs-websocket");

/**
  SOCKET SERVER
  **/

var server = ws.createServer().listen(SOCKET_PORT);

server.on("error", function(error) {
    console.log("Server Error");
});

server.on("connection", function(conn) {
  console.log("New connection");
  conn.on("text", function (str) {
    var strArr = str.split('-');
    var command = strArr[0];
    switch(command){
      case 'pause':
        if(!readableStream.isPaused())
          readableStream.pause();
        else
          readableStream.resume();
        break;
      case 'rate':
        var rate = strArr[1].replace('-', '');
        readableStream.setRate(parseInt(rate));
        break;
      default:
        console.log(`received: ${str}`);
    }
    // if(str == "pause") {
    //   // stop sending samples - but maintain connections
    //
    // } else {
    //   console.log(`received: ${str}`);
    // }
  });
  conn.on("close", function (code, reason) {
    console.log("Connection closed");
    readableStream.end();
    readableStream.destroy();
  });
  conn.on("error", function (error) {
    console.log("Connection Error");
    readableStream.end();
    readableStream.destroy();
  });


  /**
    READBALE STREAM
    **/
  readableStream.start();
  readableStream.getStream().on('data', function(chunk) {
      //console.log(`connection readystate ${conn.readyState}`);
      if(conn.readyState == 3) {
        readableStream.endStreamer();
        return;
      }
      //console.log(`writing ${chunk.length}bytes of data`);
      //data += chunk;
      conn.sendBinary(chunk);
      bytesWritten += chunk.length;
  });
  readableStream.getStream().on('error', function(error) {
      console.log(`error was generated by readable: ${error.message} - ${error.code}`);
      console.log(`${error.stack}`);
  });
  readableStream.getStream().on('end', function(){
    console.log(`readable file ended... ending writeable.. ${bytesWritten} bytes written`);
    writableStream.end();
    //readableStream = null;
    bytesWritten = 0;
  });
});
